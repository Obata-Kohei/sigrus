use crate::constants::*;

pub trait Oscillator {
    fn next_sample(&mut self) -> f32;

    fn process(&mut self, output: &mut [f32]) {
        for x in output.iter_mut() {
            *x = self.next_sample();
        }
    }
}


pub struct SinOsc {
    phase: f32,
    phase_inc: f32,
    amp: f32,
}

impl SinOsc {
    pub fn new(freq: f32, amp: f32, sample_rate: f32) -> Self {
        Self {
            phase: 0.0,
            phase_inc: TWO_PI * freq / sample_rate,
            amp,
        }
    }

    pub fn set_freq(&mut self, freq: f32, sample_rate: f32) {
        self.phase_inc = TWO_PI * freq / sample_rate;
    }
}

impl Oscillator for SinOsc {
    #[inline]
    fn next_sample(&mut self) -> f32 {
        let out = self.amp * self.phase.sin();
        self.phase += self.phase_inc;
        if self.phase >= TWO_PI {
            self.phase -= TWO_PI;
        }
        out
    }
}


pub struct SawOsc {
    phase: f32,
    phase_inc: f32,
    amp: f32,
}

impl SawOsc {
    pub fn new(freq: f32, amp: f32, sample_rate: f32) -> Self {
        Self {
            phase: 0.0,
            phase_inc: TWO_PI * freq / sample_rate,
            amp,
        }
    }

    pub fn set_freq(&mut self, freq: f32, sample_rate: f32) {
        self.phase_inc = TWO_PI * freq / sample_rate;
    }
}

impl Oscillator for SawOsc {
    #[inline]
    fn next_sample(&mut self) -> f32 {
        let u = self.phase / TWO_PI;
        let out = self.amp * (2.0 * u - 1.0);
        self.phase += self.phase_inc;
        if self.phase >= TWO_PI {
            self.phase -= TWO_PI;
        }
        out
    }
}


pub struct TriOsc {
    phase: f32,
    phase_inc: f32,
    amp: f32,
}

impl TriOsc {
    pub fn new(freq: f32, amp: f32, sample_rate: f32) -> Self {
        Self {
            phase: 0.0,
            phase_inc: TWO_PI * freq / sample_rate,
            amp,
        }
    }

    pub fn set_freq(&mut self, freq: f32, sample_rate: f32) {
        self.phase_inc = TWO_PI * freq / sample_rate;
    }
}

impl Oscillator for TriOsc {
    #[inline]
    fn next_sample(&mut self) -> f32 {
        let u = self.phase / TWO_PI;
        let out = self.amp * (1.0 - 4.0 * (u - 0.5).abs());
        self.phase += self.phase_inc;
        if self.phase >= TWO_PI {
            self.phase -= TWO_PI;
        }
        out
    }
}


pub struct SqrOsc {
    phase: f32,
    phase_inc: f32,
    amp: f32,
}

impl SqrOsc {
    pub fn new(freq: f32, amp: f32, sample_rate: f32) -> Self {
        Self {
            phase: 0.0,
            phase_inc: TWO_PI * freq / sample_rate,
            amp,
        }
    }

    pub fn set_freq(&mut self, freq: f32, sample_rate: f32) {
        self.phase_inc = TWO_PI * freq / sample_rate;
    }
}

impl Oscillator for SqrOsc {
    #[inline]
    fn next_sample(&mut self) -> f32 {
        let u = self.phase / TWO_PI;
        let out = if u < 0.5 { self.amp } else { -self.amp };
        self.phase += self.phase_inc;
        if self.phase >= TWO_PI {
            self.phase -= TWO_PI;
        }
        out
    }
}


// White noise generated by xorshift
pub struct WhiteNoise {
    state: u32,
    amp: f32,
}

impl WhiteNoise {
    pub fn new(seed: u32, amp: f32) -> Self {
        let state = if seed == 0 { 1 } else { seed };
        Self { state, amp }
    }

    #[inline]
    fn next_u32(&mut self) -> u32 {
        let mut x = self.state;
        x ^= x << 13;
        x ^= x >> 17;
        x ^= x << 5;
        self.state = x;
        x
    }
}

impl Oscillator for WhiteNoise {
    #[inline]
    fn next_sample(&mut self) -> f32 {
        let u = self.next_u32();
        let x = (u as f32) * (2.0 / u32::MAX as f32) - 1.0;
        self.amp * x
    }
}


pub struct PinkNoise {
    rows: [f32; 16],
    running_sum: f32,
    index: u32,
    rng: WhiteNoise,
    amp: f32,
}

impl PinkNoise {
    pub fn new(seed: u32, amp: f32) -> Self {
        let mut rng = WhiteNoise::new(seed, 1.0);
        let mut rows = [0.0; 16];
        let mut sum = 0.0;

        for r in rows.iter_mut() {
            *r = rng.next_sample();
            sum += *r;
        }

        Self {
            rows,
            running_sum: sum,
            index: 0,
            rng,
            amp,
        }
    }
}

impl Oscillator for PinkNoise {
    #[inline]
    fn next_sample(&mut self) -> f32 {
        self.index += 1;
        let n = self.index.trailing_zeros() as usize;

        if n < self.rows.len() {
            self.running_sum -= self.rows[n];
            self.rows[n] = self.rng.next_sample();
            self.running_sum += self.rows[n];
        }

        self.amp * (self.running_sum * (1.0 / self.rows.len() as f32))
    }
}

